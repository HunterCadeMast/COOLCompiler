Hunter Mast
PA3 - Parser

Introduction:
	For my parser, I designed it with the idea that anything being printed will come from my classes and that all of the structures build off each other to lead towards one large group of expressions and will print entire blocks and sections. For the readme.txt, I want to first discuss the starting information and setup, lexer, precedence, the AST, structure of the program, and finally, output.

Starting Information:
	With the starting information, we first get the input file's name from command line. I had followed Dr. Leach's video on building the parser, but for some reason could not get '.removesuffix' to work with the autograder. Instead, I made a small if-statement that should do the same. I check if the input file ends with '.cl-lex'. If so, we get the length of '.cl-lex' and cut it off of our file name's string to then cocatenate it with '.cl-ast'. If it does not have '.cl-lex' at the end, we just add '.cl-ast'. After that, we read the input file and read each line. We put them into a list that we will get information for our lexer from. For reading the file and getting the input lines, I also had to change this from what Dr. Leach gave us. Dr. Leach's code had been cutting off whitespaces from strings, so I change it so it keeps how the lexed file is and reads until it reachs a newline. Under this, I have 2 global variabls called class_count and error_flag. I tried to read the ClassList children that Dr. Leach gave us, but I struggled to get it to read. Instead, everytime we get a class that inherits or not, we add one to our counter. error_flag is used at the end that if we get any sort of error, we quit the program and erase the whole file.

Lexer:
	For the lexer, I followed Dr. Leach's example. We get the input lines and pop out each of the lines one by one and set them as either a line number, token type, or lexme. The big change I made is that I have my return token type in uppercase since I was having issues with it recognizing each token, which is uppercase, otherwise. My list of tokens did not change at all and was carried over directly from my lexer. Overall, this section is not too special and is mostly the same as what Dr. Leach taught in the video.

Precedence:
	For precedence, I struggled a bit to get something that felt like it was reading it all correctly. What I had was starting with LARROW as right precedence. This is because LARROW is used to assign the right to the left. EQUALS, LT, and LE are all nonassociateive for two reasons. One, Dr. Leach told us this in class and two, they just check if values are equal, less-than, or less-than or equel-to so it does matter how it is formatted. PLUS and MINUS are left precedence so it groups them from left to right. Same with TIMES and DIVIDE. This is to follow order of operations. It also have TIMES and DIVIDE more important than PLUS and MINUS since order of operations looks at that first. We have ISVOID, TILDE, and NOT both as right precedence they only deal with one value to it's right, so the right side matters the most. DOT and AT are both left precedence since they rely on having dispatch and having the leftmost method be the start. LPAREN, RPAREN, LBRACE, and RBRACE are all nonassociative as they just need to match each other.  Overall, I felt like I had a pretty accurate list of precedence, but there may be some tokens I forgot to include.

AST Classes:
	For the classes, they all start at the root node, or ASTNode. This creates an object that has 3 sections (Class nodes, feature nodes, and expression nodes). With class nodes, we have ClassList, ClassNoInherits, and ClassInherits. ClassList gets the amount of child classes, but I couldn't figure out how to fully get that number to use as our first line when writing to the program. ClassList doesn't really have much affect on anything then. ClassNoInherits and ClassInherits were both shown by Dr. Leach, but I had changed it a bit. I had received a list of features from the class that I would breakup into one long string and join with newlines that I would print. I use a similar structure of joining lists of strings with newlines throughout all of these classes. I changed slightly how the lists are formatted so that they are just one long string with newlines littered between each value. To me, this was much more condensed and help me understand what values we were inserting. It may not format them the exact same as Dr. Leach's code, but it seems pretty similar. I was able to copy most of this format of returning strings throughout all of my classes also. With ClassNoInherits and ClassInherits, the only big difference is we say what class we are inheriting from. 
	For our feature nodes, we had an Attribute, Method, and Formal class. For Attribute, we would check if we receive a any sort of initialization from our 'init_expr'. If so, we would print it out at the end with 'attribute_init'. Otherwise, we would print it with 'attribute_no_init'. Our Method class is similar, but it labels our return type and also returns the body of our method. Somehting I had to check is that some methods would not have any parameters, or formals. The way I would check this is by if there are zero or less formals. If so, we still print the amount of parameters, but we just don't print them out. Our Formal class is similar to our Attribute class. The only real difference is that we included an init_flag definition. I tried to do another function like this for ClassList, but it didn't work there. Here, it would let us know if we have an initialized expression. This is useful only really for our LET expression as I had a very hard time trying to determine if there was 'let_binding_init' or 'let_binding_no_init', which I will get to in a minute.
	For expressions, we have a lot of classes. We have Dynamic_Dispatch, Static_Dispatch, Assignment, If, While, Block, Parentheses, Let, Case, CaseCondition, BinaryOperation, Not, IsVoid, Tilde, Integer, Boolean, NewObject, and Identifier. For Dynamic_Dispatch and Static_Dispatch, they are nearly the same. They get a list of formals then decide if they are less-than or equal-to zero to know if a formal list should be included. The big difference between this and a method call is that with this, it also checks if the object happens to be a self call and will label it as 'self_dispatch'. I will go over the difference between these two when I go over the overall structure of the program. In Assignment, If, While, and Block, they all print what conditions they are doing and then will print out whatever expressions are inside of itself. Example being If. It has 3 different values that hold all of the if conditions, else conditions, and then conditions that it will print out. Parentheses is a weird one. It just prints out the list of expressions. The reason why is that in COOL's reference parser, it does not label parentheses. I still need to recognize them, but I just need to print the expressions inside of them. Let was a hard one to work on. With it, I had to use the 'init_flag' definition from our Formal class and if any formal activated this flag, we would label our let binding accordingly. I struggled for quite a while before I realized I would use classes to my advantage and pass info between them. I most likely could have utilized this better, but it works well for what it is. For Case, I had separated this into two different classes. One would label the case and then list the conditions inside of it. The conditions would be gathered by the class CaseCondition in the correct formatting. The rest of the classes I listed do not have anything else really different from what I explained above. They mostly just spit out the list of expressions or the expression it is currently looking at. BinaryOperation does give the operation that is being used, so it did have to be passed directly instead of using 'p[#]' and the tokens because for some reason, it would always be blank. I will get into that thougn in the next section. Boolean class also had the same issue. One reason I had also used '.join' to add everything into a string is that before hand, I was just return each list I would receive directly. This would then have a ton of nested lists that would lead to it being printed with square brackets all around. This way, we were able to directly print each line as a string and not lists.

Structure:
	For our structure, I had initially set it up just like Dr. Leach's video. I had program to some classlist or none. Biggest different with the class structure is that I included 'class_count' inside of class_no_inherits and class_inherits. I believe I also added 'p.lineno(1)' to each of my statements if it was not there already. This was just to get the line number for every class, expression, method, etc. For our feature list, I took Dr. Leach's advice and pretty much copied the class structure. Biggest difference is that for feature_no_init, I was getting the identifier and type and giving that to our Attribute class. For feature_init, I included the expression that the identifier would be initialized to. feature_method is a bit harder. For it, I needed to have it so any method could have parameters or not. The parameters came in the form of a formal list. It is exactly the same as the last 2 structures except for it goes to the Formal class and in formal_list, we use 'formaldef COMMA formal_list'. Doing this, we are able to have as many parameters as we want. The same idea is kept for our expressions. In exprlist, we have it so that there is a semicolon between expressions, a comma, a single expression, or just a statement. This is because our expressions are the meat and potatoes of our code here along with formals, in my opinion. Our expressions build a lot off of the tokens we have and are used in a variety of ways.B Usually, it works in tandem with our formals though. Block and parentheses are similar, but the classes do different outputs. Assignment is similar to initializing a formal, but here, we do not initialize. We are just reassigning a variable to another value. Our If and While statement are very similar and just send whatever expression output is between each of our statements. Where we get a bit more complicated is at our let structure. With it, it gets a formal list of assigning groups of variables/identifiers to values. It's class has to decide if the formal list it is getting has any initialization, which I explained before. This is also a bit more complicated than I initially thought because something I had to add is if there are multiple different variables for let, they need to be separated by a comma and said if they are initialized or not. Case calls our 'p_case_condition_list', which is very important. That structure is pretty much the same as our formals. I believe it probably could have been optimized and just use formal_list, but for some reason I decided to separate them. I think it was because the CaseCondition class gives different output than the Formal class, but I am not sure. I may look at this closer on PA6 where I can try to optimize this. For all of our binary operations, I could not figure out how to get the token to be read and passed through using p[2]. Instead, I just directly told each class what to output, depending on the token. My unary operators like isvoid, not, and tilde all use p[2] though. For integers, strings, bool, new object, and identifiers, it just recognizes the token itself if nothing else did and will print accordingly. Booleans were my hardest to do. For some reason, when having them together in one class, it would not send the token out as False or True. It would be blank. My solution eventually was to seperate them into 2 different structures, each sending back 'true' or 'false' directly as strings. The hardest expression for me was probably doing method dispatch. I had one structure that deals with every variation that dispatch can be, including the AT token and DOT token, along with the expression possibly being an identifier or not. It maybe has some useless expressions in it, but it works fine from what I can see so I won't worry about that now. Depending on the length of what we need to parse, we either go to the Static_Dispatch class or Dynamic_Dispatch. 4 of the 6 options are dynamic because it allows for both having parameters or not and then also being a self dispatch or not. Static can have both parameters or not. I don't believe there is static self dispatch, even though I have it in my Static Dispatch class, but I left it there just in case it got past and would not throw an error. Dealing with dispatch like this was very hard to wrap my head around, but I believe I got it in the end. Something else I should have done is make LET be like CASE where the conditions inside are separated, but I made CASE after LET and when trying to fix LET, I struggled to separate it from formal_list. When optimizing this, I think creating a LetCondition class would be a better way of checking than just checking through the Formal class.

Output:
	For the output, it is pretty simple. Our error structure pretty simply just prints if there is an error, it's line number, and what value the issue came from. If there is no error, we start writing to our file using all of the parsed info in our ast list Dr. Leach showed us how to set up. Something I added is that I have encoding set to 'utf-8'. At first, I failed all my negative test cases, which Dr. Leach said may be from not allowing for cross-platform. I added this to make it for standard character encoding and I believe it works now for writing test cases. The first line is that we write our class count as a string to the first line. After that, we then start going through our ast list for every node and writing them as a string one by one. If there is an error, just exit our program before we write anything to it. This is all pretty simple, but works great. I did add a check inside of the Case class and Let class that would swee if there is nothing between let and in and between case and esac that we print an error and exit our program.

good.cl and bad.cl:
	For good.cl, I used the same file as I used for my lexer. I used a lexed version of good.cl and ran it through both the reference parser and my own. One thing it did help with is that I used to have a funcition for unary operations like not, isvoid, and tilde. It helped me realize that tilde was not being recognized properly, so I removed it and made it all 3 different classes. The big issue I cannot figure out for it is that it has a let statement in one like of the reference parser, but my parser does not print 'let_binding' for it. The rest of the code is fine, but this one line does not print. Overall, it works great though. Some other tests I had were using arith.cl again since that handles a lot of different aspects of the COOL language and a lot of different operations, along with a good amount of classes and methods. I made 3 other tests myself though. One is called class.cl. It is just the first class of arith.cl, but it helped me in a smalled file to make sure that self types are recognized and that classes were being properly counted and recognized. expression.cl was meant to check a lot more expressions in depth with an if-statement, while-statement, and a let. Finally, we had extra.cl which was to test a lot more of the other expressions that were not in arith.cl and that I wanted to test more specifically. A case statement and new object were the main two that I was testing with it. I added the classes and methods from expression.cl, extra.cl, and class.cl into the end of good.cl to show some more test cases.
	For bad.cl, I struggled a bit. I tried for a bit with having bad.cl be good.cl-lex and then I would remove or change tokens, identifiers, etc. One test I used the lexed version for was erasing both the contents of a let statement and a case statement. By doing this, it allowed me to test that if we have an empty CASE or LET, we should throw an error. Eventually, I tried to instead make bad.cl a worse version of good.cl. What I mean by this is that good.cl would pass our lexer and then pass our parser. What I wanted to test is something that would still get past our lexer, but would not pass our parser. This way was more realistici and would show By messing with bad.cl this way also, I was able to see compared to good.cl what could go wrong in a working file, even with slight changes. With this logic, I was able to edit a lot of this bad file and show what worked and what didn't. I added some errors to show in bad.cl that will show an error being presented. Some errors I added was:

	Line 45 - No semi colon.
	Line 64 - No inherits class defined.
	Line 72 - No case conditions.
	Line 74 - No let conditions.
	Line 102 - Extra comma in parameters.
	Line 122 - No semi colon at the end of file.

Conclusion:
	Overall, this was a very complex project. Like I mentioned before, dispatch and let were most likely the hardest parts to consider. A lot of parsing seems to be considering every option and possibility, which was very cool to do. It was very cool to see how the tree formed and what could be turned into what. I believe there are some possibilities to optimize this, as I mentioned before. There is also a few bugs that I struggled to figure out. One being errors not properly reporting. I will try to fix it in the next day or so, but it does pass most of the initial tests, which is great. I look forward to see how I can get this to work with type checking and all that it has to offer.